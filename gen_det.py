#Import the necessary functions
import cv2
import numpy as np
import os
import argparse


def get_gall_bladder(source_of_image, final_destination):
    
    #print(source_of_image)
    #print(final_destination)
    
    source_img = cv2.imread(source_of_image, 0)
    
    #print(type(source_of_image))
    
    gauss = source_img.copy()
    bilateral = source_img.copy()

    N = 100
    for i in range(N):
        gauss = cv2.GaussianBlur(gauss, (3, 3), 0)

    for i in range(N):
        bilateral = cv2.bilateralFilter(bilateral, 3, 5, 5)

    ## Adaptive thresholding
    adaptive_thresh_gauss = cv2.adaptiveThreshold(gauss, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 399, 1)
    ## Best at (399, 1)
    
    adaptive_thresh_bilateral = cv2.adaptiveThreshold(bilateral, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 495, 19)
    ## Best at (495, 19)

    _ , ostu_gauss = cv2.threshold(gauss, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    _ , ostu_bilateral = cv2.threshold(bilateral, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    ## Adaptive thresholding technique does better in identifying the regions of the gall bladder, whereas Ostu's binarization gives sharper regions
    ## We take their intersection to get the best region.

    gaussian_and = cv2.bitwise_and(adaptive_thresh_gauss, ostu_gauss)
    bilateral_and = cv2.bitwise_and(adaptive_thresh_bilateral, ostu_bilateral)

    overall_and = cv2.bitwise_and(gaussian_and, bilateral_and)

    ## Visually, the overall_and seems the best

    laplace = cv2.Laplacian(overall_and, -1, 3)

    ## Find all the contours generated by the laplacian
    contours, hierarchy = cv2.findContours(laplace.copy(),cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

    ## Go through all the contours, calculate their area and find the contour with maximum area in a range.
    ## The range is determined by the size of the input image.
    m = -1
    max_area = -1
    for i, cont in enumerate(contours):
        area = cv2.contourArea(cont)
        if((area > max_area) and (area < 0.1*source_img.size)):
            max_area = area
            m = i

    ## draw the contour found[Gall bladder] on a blank canvas. Fill the entire contour
    mask = np.zeros(source_img.shape+(3, ), dtype='uint8')
    cv2.drawContours(mask, [contours[m]], -1, (255,255,255), -1)

    cv2.imwrite(final_destination, mask)

    
##Main Method
if __name__ == "__main__":
    
    #Describing command line usage
    parser = argparse.ArgumentParser(description = 'Script for generating segmentation mask of gall bladder images')
    parser.add_argument('-i', '--img_path', type = str, default = 'img', required = True, help = "Path to the image folder")
    parser.add_argument('-d', '--det_path', type = str, default = 'val_masks', required = True, help = "Path to the folder where mask will be stored")
    
    #Parsing folder in which image is contained and the destination folder where the image has to be stored
    args = parser.parse_args()
    src_folder =  args.img_path
    dst_folder  = args.det_path
    
    #All the images in the source directory
    src_files = os.listdir(src_folder)
    
    #If the destination directory doesn't exist then create it
    if not os.path.exists(dst_folder):
        os.makedirs(dst_folder)
        
    #Generate mask for all the imput images
    for src_file in src_files:
        file = src_file[:-4] + ".png"
        get_gall_bladder(src_folder+src_file, dst_folder+file)
        
    print("Done!")
